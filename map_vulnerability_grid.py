# map_vulnerability_grid.py
#
# C2 â€“ HartÄƒ de vulnerabilitate pe o grilÄƒ regulatÄƒ
# FoloseÈ™te ground_truth_with_predictions.csv, care conÈ›ine:
#   lat, lon, pred_class (sau pred_label), etc.
#
# Output:
#   figures/vulnerability_grid.png

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

from config import PROCESSED_DIR, FIGURES_DIR


def main():
    csv_path = PROCESSED_DIR / "ground_truth_with_predictions.csv"
    print(f"ğŸ“‚ Loading predictions from {csv_path}")

    df = pd.read_csv(csv_path)

    # --- determinÄƒm coloana cu labelul de vulnerabilitate ---
    label_col = None
    if "pred_label" in df.columns:
        label_col = "pred_label"
    elif "pred_class" in df.columns:
        label_col = "pred_class"

    if label_col is None:
        raise ValueError(
            "Nu am gÄƒsit nici 'pred_label', nici 'pred_class' Ã®n CSV. "
            f"Coloane existente: {list(df.columns)}"
        )

    # VerificÄƒm È™i coloanele de coordonate
    for col in ("lat", "lon"):
        if col not in df.columns:
            raise ValueError(
                f"CSV-ul trebuie sÄƒ conÈ›inÄƒ coloana '{col}'. "
                f"Coloane gÄƒsite: {list(df.columns)}"
            )

    # PÄƒstrÄƒm doar ce ne trebuie pentru hartÄƒ
    df = df[["lat", "lon", label_col]].dropna()

    print("âœ… First rows:")
    print(df.head())

    # --- definim grila spaÈ›ialÄƒ ---
    lat_min, lat_max = df["lat"].min(), df["lat"].max()
    lon_min, lon_max = df["lon"].min(), df["lon"].max()
    print(f"ğŸ“ Lat range: {lat_min:.3f} â€“ {lat_max:.3f}")
    print(f"ğŸ“ Lon range: {lon_min:.3f} â€“ {lon_max:.3f}")

    # RezoluÈ›ia grilei (poÈ›i ajusta: 80, 100, etc.)
    n_lat_bins = 80
    n_lon_bins = 80

    lat_edges = np.linspace(lat_min, lat_max, n_lat_bins + 1)
    lon_edges = np.linspace(lon_min, lon_max, n_lon_bins + 1)

    # Matrice pentru vulnerabilitate (medie pe celulÄƒ)
    grid = np.full((n_lat_bins, n_lon_bins), np.nan)
    counts = np.zeros((n_lat_bins, n_lon_bins), dtype=int)

    # DeterminÄƒm Ã®n ce celulÄƒ de grilÄƒ intrÄƒ fiecare punct
    lat_idx = np.digitize(df["lat"].values, lat_edges) - 1
    lon_idx = np.digitize(df["lon"].values, lon_edges) - 1

    vals = df[label_col].values.astype(float)

    for li, lo, v in zip(lat_idx, lon_idx, vals):
        if 0 <= li < n_lat_bins and 0 <= lo < n_lon_bins:
            if np.isnan(grid[li, lo]):
                grid[li, lo] = v
                counts[li, lo] = 1
            else:
                # medie pe celulÄƒ (poÈ›i schimba ulterior Ã®n "majority vote")
                grid[li, lo] = (grid[li, lo] * counts[li, lo] + v) / (counts[li, lo] + 1)
                counts[li, lo] += 1

    # Construim coordonatele centrelor de celulÄƒ pentru plotting
    lat_centers = 0.5 * (lat_edges[:-1] + lat_edges[1:])
    lon_centers = 0.5 * (lon_edges[:-1] + lon_edges[1:])

    Lon, Lat = np.meshgrid(lon_centers, lat_centers)

    # --- plot hartÄƒ ---
    FIGURES_DIR.mkdir(parents=True, exist_ok=True)
    out_path = FIGURES_DIR / "vulnerability_grid.png"

    plt.figure(figsize=(8, 8))
    im = plt.pcolormesh(
        Lon,
        Lat,
        grid,
        shading="auto",
        cmap="viridis"
    )
    cbar = plt.colorbar(im)
    cbar.set_label("Predicted vulnerability class")

    plt.xlabel("Longitude")
    plt.ylabel("Latitude")
    plt.title("AgriVuln-AI â€“ vulnerability grid (Kenya)")

    plt.tight_layout()
    plt.savefig(out_path, dpi=300)
    print(f"ğŸ’¾ Saved vulnerability grid map to: {out_path}")
    plt.close()


if __name__ == "__main__":
    main()
